No,Category,Guideline,指导方针,Description,描述,Do,推荐做法,Don't,不推荐做法,Code Good,良好代码,Code Bad,不良代码,Severity,Docs URL
1,状态 | State,Use useState for local state,本地状态使用 useState,Simple component state should use useState hook,简单组件状态应使用 useState hook,useState for form inputs toggles counters,表单输入、开关、计数器使用 useState,Class components this.state,类组件 this.state,"const [count, setCount] = useState(0)","const [count, setCount] = useState(0)",this.state = { count: 0 },this.state = { count: 0 },中等 | Medium,https://react.dev/reference/react/useState
2,状态 | State,Lift state up when needed,需要时提升状态,Share state between siblings by lifting to parent,通过提升到父组件在兄弟组件间共享状态,Lift shared state to common ancestor,将共享状态提升到公共祖先,Prop drilling through many levels,通过多层级传递 props,Parent holds state passes down,父组件持有状态并向下传递,Deep prop chains,深层级 prop 链,中等 | Medium,https://react.dev/learn/sharing-state-between-components
3,状态 | State,Use useReducer for complex state,复杂状态使用 useReducer,Complex state logic benefits from reducer pattern,复杂状态逻辑受益于 reducer 模式,useReducer for state with multiple sub-values,多个子值的状态使用 useReducer,Multiple useState for related values,相关值使用多个 useState,useReducer with action types,useReducer 配合 action 类型,5+ useState calls that update together,5+ 个一起更新的 useState 调用,中等 | Medium,https://react.dev/reference/react/useReducer
4,状态 | State,Avoid unnecessary state,避免不必要的状态,Derive values from existing state when possible,尽可能从现有状态派生值,Compute derived values in render,在 render 中计算派生值,Store derivable values in state,将可派生值存储在状态中,const total = items.reduce(...),const total = items.reduce(...),"const [total, setTotal] = useState(0)","const [total, setTotal] = useState(0)",高 | High,https://react.dev/learn/choosing-the-state-structure
5,状态 | State,Initialize state lazily,懒初始化状态,Use function form for expensive initial state,昂贵的初始状态使用函数形式,useState(() => computeExpensive()),useState(() => computeExpensive()),useState(computeExpensive()),useState(computeExpensive()),useState(() => JSON.parse(data)),useState(() => JSON.parse(data)),useState(JSON.parse(data)),useState(JSON.parse(data)),中等 | Medium,https://react.dev/reference/react/useState#avoiding-recreating-the-initial-state
6,副作用 | Effects,Clean up effects,清理副作用,Return cleanup function for subscriptions timers,订阅和定时器返回清理函数,Return cleanup function in useEffect,在 useEffect 中返回清理函数,No cleanup for subscriptions,订阅无清理,useEffect(() => { sub(); return unsub; }),useEffect(() => { sub(); return unsub; }),useEffect(() => { subscribe(); }),useEffect(() => { subscribe(); }),高 | High,https://react.dev/reference/react/useEffect#connecting-to-an-external-system
7,副作用 | Effects,Specify dependencies correctly,正确指定依赖项,Include all values used inside effect in deps array,将 effect 内使用的所有值包含在依赖数组中,All referenced values in dependency array,所有引用的值放入依赖数组,Empty deps with external references,使用外部引用时空依赖,[value] when using value in effect,effect 中使用 value 时依赖 [value],[] when using props/state in effect,effect 中使用 props/state 时依赖 [],高 | High,https://react.dev/reference/react/useEffect#specifying-reactive-dependencies
8,副作用 | Effects,Avoid unnecessary effects,避免不必要的副作用,Don't use effects for transforming data or events,不要用 effects 转换数据或处理事件,Transform data during render handle events directly,在渲染时转换数据直接处理事件,useEffect for derived state or event handling,派生状态或事件处理使用 useEffect,const filtered = items.filter(...),const filtered = items.filter(...),useEffect(() => setFiltered(items.filter(...))),useEffect(() => setFiltered(items.filter(...))),高 | High,https://react.dev/learn/you-might-not-need-an-effect
9,副作用 | Effects,Use refs for non-reactive values,非响应式值使用 refs,Store values that don't trigger re-renders in refs,将不触发重新渲染的值存储在 refs 中,useRef for interval IDs DOM elements,interval ID 和 DOM 元素使用 useRef,useState for values that don't need render,不需要触发渲染的值使用 useState,const intervalRef = useRef(null),const intervalRef = useRef(null),"const [intervalId, setIntervalId] = useState()","const [intervalId, setIntervalId] = useState()",中等 | Medium,https://react.dev/reference/react/useRef
10,渲染 | Rendering,Use keys properly,正确使用 keys,Stable unique keys for list items,列表项使用稳定的唯一 keys,Use stable IDs as keys,使用稳定的 ID 作为 keys,Array index as key for dynamic lists,动态列表使用数组索引作为 key,key={item.id},key={item.id},key={index},key={index},高 | High,https://react.dev/learn/rendering-lists#keeping-list-items-in-order-with-key
11,渲染 | Rendering,Memoize expensive calculations,记忆化昂贵的计算,Use useMemo for costly computations,昂贵计算使用 useMemo,useMemo for expensive filtering/sorting,昂贵的过滤/排序使用 useMemo,Recalculate every render,每次渲染重新计算,"useMemo(() => expensive(), [deps])","useMemo(() => expensive(), [deps])",const result = expensiveCalc(),const result = expensiveCalc(),中等 | Medium,https://react.dev/reference/react/useMemo
12,渲染 | Rendering,Memoize callbacks passed to children,记忆化传递给子组件的回调,Use useCallback for functions passed as props,传递给 props 的函数使用 useCallback,useCallback for handlers passed to memoized children,传递给记忆化子组件的处理器使用 useCallback,New function reference every render,每次渲染新的函数引用,"useCallback(() => {}, [deps])","useCallback(() => {}, [deps])",const handler = () => {},const handler = () => {},中等 | Medium,https://react.dev/reference/react/useCallback
13,渲染 | Rendering,Use React.memo wisely,明智使用 React.memo,Wrap components that render often with same props,包装经常使用相同 props 渲染的组件,memo for pure components with stable props,稳定 props 的纯组件使用 memo,memo everything or nothing,记忆化所有或不记忆化,memo(ExpensiveList),memo(ExpensiveList),memo(SimpleButton),memo(SimpleButton),低 | Low,https://react.dev/reference/react/memo
14,渲染 | Rendering,Avoid inline object/array creation in JSX,JSX 中避免内联对象/数组创建,Create objects outside render or memoize,在渲染外创建对象或记忆化,Define style objects outside component,在组件外定义样式对象,Inline objects in props,props 中内联对象,<div style={styles.container}>,<div style={styles.container}>,<div style={{ margin: 10 }}>,<div style={{ margin: 10 }}>,中等 | Medium,
15,组件 | Components,Keep components small and focused,保持组件小而专注,Single responsibility for each component,每个组件单一职责,One concern per component,每个组件一个关注点,Large multi-purpose components,大型多用途组件,<UserAvatar /><UserName />,<UserAvatar /><UserName />,<UserCard /> with 500 lines,<UserCard /> 500 行代码,中等 | Medium,
16,组件 | Components,Use composition over inheritance,使用组合而非继承,Compose components using children and props,使用 children 和 props 组合组件,Use children prop for flexibility,使用 children prop 提高灵活性,Inheritance hierarchies,继承层级,<Card>{content}</Card>,<Card>{content}</Card>,class SpecialCard extends Card,class SpecialCard extends Card,中等 | Medium,https://react.dev/learn/thinking-in-react
17,组件 | Components,Colocate related code,相关代码放在一起,Keep related components and hooks together,将相关组件和 hooks 放在一起,Related files in same directory,相关文件放在同一目录,Flat structure with many files,扁平结构多文件,components/User/UserCard.tsx,components/User/UserCard.tsx,components/UserCard.tsx + hooks/useUser.ts,components/UserCard.tsx + hooks/useUser.ts,低 | Low,
18,组件 | Components,Use fragments to avoid extra DOM,使用 fragments 避免额外 DOM,Fragment or <> for multiple elements without wrapper,多个元素无包装器使用 Fragment 或 <>,<> for grouping without DOM node,分组无 DOM 节点使用 <>,Extra div wrappers,额外的 div 包装器,<>{items.map(...)}</>,<>{items.map(...)}</>,<div>{items.map(...)}</div>,<div>{items.map(...)}</div>,低 | Low,https://react.dev/reference/react/Fragment
19,属性 | Props,Destructure props,解构 props,Destructure props for cleaner component code,解构 props 使组件代码更清晰,Destructure in function signature,在函数签名中解构,props.name props.value throughout,到处使用 props.name props.value,"function User({ name, age })","function User({ name, age })",function User(props),function User(props),低 | Low,
20,属性 | Props,Provide default props values,提供默认 props 值,Use default parameters or defaultProps,使用默认参数或 defaultProps,Default values in destructuring,解构中使用默认值,Undefined checks throughout,到处检查 undefined,function Button({ size = 'md' }),function Button({ size = 'md' }),if (size === undefined) size = 'md',if (size === undefined) size = 'md',低 | Low,
21,属性 | Props,Avoid prop drilling,避免 prop 传递,Use context or composition for deeply nested data,深层嵌套数据使用 context 或组合,Context for global data composition for UI,全局数据使用 Context UI 使用组合,Passing props through 5+ levels,通过 5+ 层级传递 props,<UserContext.Provider>,<UserContext.Provider>,<A user={u}><B user={u}><C user={u}>,<A user={u}><B user={u}><C user={u}>,中等 | Medium,https://react.dev/learn/passing-data-deeply-with-context
22,属性 | Props,Validate props with TypeScript,使用 TypeScript 验证 props,Use TypeScript interfaces for prop types,使用 TypeScript 接口定义 prop 类型,interface Props { name: string },interface Props { name: string },PropTypes or no validation,PropTypes 或不验证,interface ButtonProps { onClick: () => void },interface ButtonProps { onClick: () => void },Button.propTypes = {},Button.propTypes = {},中等 | Medium,
23,事件 | Events,Use synthetic events correctly,正确使用合成事件,React normalizes events across browsers,React 跨浏览器规范化事件,e.preventDefault() e.stopPropagation(),e.preventDefault() e.stopPropagation(),Access native event unnecessarily,不必要地访问原生事件,onClick={(e) => e.preventDefault()},onClick={(e) => e.preventDefault()},onClick={(e) => e.nativeEvent.preventDefault()},onClick={(e) => e.nativeEvent.preventDefault()},低 | Low,https://react.dev/reference/react-dom/components/common#react-event-object
24,事件 | Events,Avoid binding in render,避免在 render 中绑定,Use arrow functions in class or hooks,类或 hooks 中使用箭头函数,Arrow functions in functional components,函数组件中使用箭头函数,bind in render or constructor,在 render 或构造函数中 bind,const handleClick = () => {},const handleClick = () => {},this.handleClick.bind(this),this.handleClick.bind(this),中等 | Medium,
25,事件 | Events,Pass event handlers not call results,传递事件处理器而非调用结果,Pass function reference not invocation,传递函数引用而非调用,onClick={handleClick},onClick={handleClick},onClick={handleClick()} causing immediate call,onClick={handleClick()} 导致立即调用,onClick={handleClick},onClick={handleClick},onClick={handleClick()},onClick={handleClick()},高 | High,
26,表单 | Forms,Controlled components for forms,表单使用受控组件,Use state to control form inputs,使用状态控制表单输入,value + onChange for inputs,输入使用 value + onChange,Uncontrolled inputs with refs,使用 refs 的非受控输入,<input value={val} onChange={setVal}>,<input value={val} onChange={setVal}>,<input ref={inputRef}>,<input ref={inputRef}>,中等 | Medium,https://react.dev/reference/react-dom/components/input#controlling-an-input-with-a-state-variable
27,表单 | Forms,Handle form submission properly,正确处理表单提交,Prevent default and handle in submit handler,阻止默认行为并在 submit 处理器中处理,onSubmit with preventDefault,onSubmit 配合 preventDefault,onClick on submit button only,仅在提交按钮使用 onClick,<form onSubmit={handleSubmit}>,<form onSubmit={handleSubmit}>,<button onClick={handleSubmit}>,<button onClick={handleSubmit}>,中等 | Medium,
28,表单 | Forms,Debounce rapid input changes,防抖快速输入变化,Debounce search/filter inputs,搜索/过滤输入使用防抖,useDeferredValue or debounce for search,搜索使用 useDeferredValue 或 debounce,Filter on every keystroke,每次按键都过滤,useDeferredValue(searchTerm),useDeferredValue(searchTerm),useEffect filtering on every change,每次变化都 useEffect 过滤,中等 | Medium,https://react.dev/reference/react/useDeferredValue
29,Hooks,Follow rules of hooks,遵循 hooks 规则,Only call hooks at top level and in React functions,仅在顶层和 React 函数中调用 hooks,Hooks at component top level,Hooks 在组件顶层,Hooks in conditions loops or callbacks,条件、循环或回调中使用 Hooks,"const [x, setX] = useState()","const [x, setX] = useState()","if (cond) { const [x, setX] = useState() }","if (cond) { const [x, setX] = useState() }",高 | High,https://react.dev/reference/rules/rules-of-hooks
30,Hooks,Custom hooks for reusable logic,可重用逻辑使用自定义 hooks,Extract shared stateful logic to custom hooks,将共享的有状态逻辑提取到自定义 hooks,useCustomHook for reusable patterns,可重用模式使用 useCustomHook,Duplicate hook logic across components,跨组件重复 hook 逻辑,const { data } = useFetch(url),const { data } = useFetch(url),Duplicate useEffect/useState in components,组件中重复 useEffect/useState,中等 | Medium,https://react.dev/learn/reusing-logic-with-custom-hooks
31,Hooks,Name custom hooks with use prefix,自定义 hooks 使用 use 前缀,Custom hooks must start with use,自定义 hooks 必须以 use 开头,useFetch useForm useAuth,useFetch useForm useAuth,fetchData or getData for hook,hook 使用 fetchData 或 getData,function useFetch(url),function useFetch(url),function fetchData(url),function fetchData(url),高 | High,
32,上下文 | Context,Use context for global data,全局数据使用 context,Context for theme auth locale,主题、认证、语言使用 Context,Context for app-wide state,应用全局状态使用 Context,Context for frequently changing data,频繁变化数据使用 Context,<ThemeContext.Provider>,<ThemeContext.Provider>,Context for form field values,表单字段值使用 Context,中等 | Medium,https://react.dev/learn/passing-data-deeply-with-context
33,上下文 | Context,Split contexts by concern,按关注点拆分 contexts,Separate contexts for different domains,不同领域使用独立 contexts,ThemeContext + AuthContext,ThemeContext + AuthContext,One giant AppContext,一个巨大的 AppContext,<ThemeProvider><AuthProvider>,<ThemeProvider><AuthProvider>,<AppProvider value={{theme user...}}>,<AppProvider value={{theme user...}}>,中等 | Medium,
34,上下文 | Context,Memoize context values,记忆化 context 值,Prevent unnecessary re-renders with useMemo,使用 useMemo 防止不必要的重新渲染,useMemo for context value object,context 值对象使用 useMemo,New object reference every render,每次渲染新的对象引用,"value={useMemo(() => ({...}), [])}","value={useMemo(() => ({...}), [])}","value={{ user, theme }}","value={{ user, theme }}",高 | High,
35,性能 | Performance,Use React DevTools Profiler,使用 React DevTools Profiler,Profile to identify performance bottlenecks,性能分析识别瓶颈,Profile before optimizing,优化前先分析,Optimize without measuring,不测量就优化,React DevTools Profiler,React DevTools Profiler,Guessing at bottlenecks,猜测瓶颈,中等 | Medium,https://react.dev/learn/react-developer-tools
36,性能 | Performance,Lazy load components,懒加载组件,Use React.lazy for code splitting,使用 React.lazy 进行代码分割,lazy() for routes and heavy components,路由和重型组件使用 lazy(),Import everything upfront,提前导入所有内容,const Page = lazy(() => import('./Page')),const Page = lazy(() => import('./Page')),import Page from './Page',import Page from './Page',中等 | Medium,https://react.dev/reference/react/lazy
37,性能 | Performance,Virtualize long lists,虚拟化长列表,Use windowing for lists over 100 items,超过 100 项的列表使用窗口化,react-window or react-virtual,使用 react-window 或 react-virtual,Render thousands of DOM nodes,渲染数千个 DOM 节点,<VirtualizedList items={items}/>,<VirtualizedList items={items}/>,{items.map(i => <Item />)},{items.map(i => <Item />)},高 | High,
38,性能 | Performance,Batch state updates,批量更新状态,React 18 auto-batches but be aware,React 18 自动批量更新但需注意,Let React batch related updates,让 React 批量处理相关更新,Manual batching with flushSync,使用 flushSync 手动批量,setA(1); setB(2); // batched,setA(1); setB(2); // batched,flushSync(() => setA(1)),flushSync(() => setA(1)),低 | Low,https://react.dev/learn/queueing-a-series-of-state-updates
39,错误处理 | ErrorHandling,Use error boundaries,使用错误边界,Catch JavaScript errors in component tree,捕获组件树中的 JavaScript 错误,ErrorBoundary wrapping sections,ErrorBoundary 包装区块,Let errors crash entire app,让错误崩溃整个应用,<ErrorBoundary><App/></ErrorBoundary>,<ErrorBoundary><App/></ErrorBoundary>,No error handling,无错误处理,高 | High,https://react.dev/reference/react/Component#catching-rendering-errors-with-an-error-boundary
40,错误处理 | ErrorHandling,Handle async errors,处理异步错误,Catch errors in async operations,捕获异步操作中的错误,try/catch in async handlers,异步处理器中使用 try/catch,Unhandled promise rejections,未处理的 promise 拒绝,try { await fetch() } catch(e) {},try { await fetch() } catch(e) {},await fetch() // no catch,await fetch() // no catch,高 | High,
41,测试 | Testing,Test behavior not implementation,测试行为而非实现,Test what user sees and does,测试用户看到和做的,Test renders and interactions,测试渲染和交互,Test internal state or methods,测试内部状态或方法,expect(screen.getByText('Hello')),expect(screen.getByText('Hello')),expect(component.state.name),expect(component.state.name),中等 | Medium,https://testing-library.com/docs/react-testing-library/intro/
42,测试 | Testing,Use testing-library queries,使用 testing-library 查询,Use accessible queries,使用无障碍查询,getByRole getByLabelText,getByRole getByLabelText,getByTestId for everything,所有地方使用 getByTestId,getByRole('button'),getByRole('button'),getByTestId('submit-btn'),getByTestId('submit-btn'),中等 | Medium,https://testing-library.com/docs/queries/about#priority
43,无障碍 | Accessibility,Use semantic HTML,使用语义化 HTML,Proper HTML elements for their purpose,为其用途使用正确的 HTML 元素,button for clicks nav for navigation,点击使用 button 导航使用 nav,div with onClick for buttons,按钮使用带 onClick 的 div,<button onClick={...}>,<button onClick={...}>,<div onClick={...}>,<div onClick={...}>,高 | High,https://react.dev/reference/react-dom/components#all-html-components
44,无障碍 | Accessibility,Manage focus properly,正确管理焦点,Handle focus for modals dialogs,处理模态框和对话框的焦点,Focus trap in modals return focus on close,模态框中焦点陷阱关闭时返回焦点,No focus management,无焦点管理,useEffect to focus input,useEffect 聚焦输入,Modal without focus trap,无焦点陷阱的模态框,高 | High,
45,无障碍 | Accessibility,Announce dynamic content,播报动态内容,Use ARIA live regions for updates,更新使用 ARIA live 区域,aria-live for dynamic updates,动态更新使用 aria-live,Silent updates to screen readers,屏幕阅读器静默更新,"<div aria-live=""polite"">{msg}</div>","<div aria-live=""polite"">{msg}</div>",<div>{msg}</div>,<div>{msg}</div>,中等 | Medium,
46,无障碍 | Accessibility,Label form controls,标记表单控件,Associate labels with inputs,将标签与输入关联,htmlFor matching input id,htmlFor 匹配 input id,Placeholder as only label,仅占位符作为标签,"<label htmlFor=""email"">Email</label>","<label htmlFor=""email"">Email</label>","<input placeholder=""Email""/>","<input placeholder=""Email""/>",高 | High,
47,TypeScript,Type component props,类型化组件 props,Define interfaces for all props,为所有 props 定义接口,interface Props with all prop types,interface Props 包含所有 prop 类型,any or missing types,any 或缺失类型,interface Props { name: string },interface Props { name: string },function Component(props: any),function Component(props: any),高 | High,
48,TypeScript,Type state properly,正确类型化状态,Provide types for useState,为 useState 提供类型,useState<Type>() for complex state,复杂状态使用 useState<Type>(),Inferred any types,推断为 any 类型,useState<User | null>(null),useState<User | null>(null),useState(null),useState(null),中等 | Medium,
49,TypeScript,Type event handlers,类型化事件处理器,Use React event types,使用 React 事件类型,React.ChangeEvent<HTMLInputElement>,React.ChangeEvent<HTMLInputElement>,Generic Event type,通用 Event 类型,onChange: React.ChangeEvent<HTMLInputElement>,onChange: React.ChangeEvent<HTMLInputElement>,onChange: Event,onChange: Event,中等 | Medium,
50,TypeScript,Use generics for reusable components,可重用组件使用泛型,Generic components for flexible typing,泛型组件提供灵活类型,Generic props for list components,列表组件使用泛型 props,Union types for flexibility,联合类型提供灵活性,<List<T> items={T[]}>,<List<T> items={T[]}>,<List items={any[]}>,<List items={any[]}>,中等 | Medium,
51,模式 | Patterns,Container/Presentational split,容器/展示分离,Separate data logic from UI,将数据逻辑与 UI 分离,Container fetches presentational renders,容器获取数据展示组件渲染,Mixed data and UI in one,数据和 UI 混合在一起,<UserContainer><UserView/></UserContainer>,<UserContainer><UserView/></UserContainer>,<User /> with fetch and render,<User /> 包含获取和渲染,低 | Low,
52,模式 | Patterns,Render props for flexibility,灵活性使用 render props,Share code via render prop pattern,通过 render prop 模式共享代码,Render prop for customizable rendering,可自定义渲染使用 render prop,Duplicate logic across components,跨组件重复逻辑,<DataFetcher render={data => ...}/>,<DataFetcher render={data => ...}/>,Copy paste fetch logic,复制粘贴获取逻辑,低 | Low,https://react.dev/reference/react/cloneElement#passing-data-with-a-render-prop
53,模式 | Patterns,Compound components,复合组件,Related components sharing state,相关组件共享状态,Tab + TabPanel sharing context,Tab + TabPanel 共享 context,Prop drilling between related,相关组件间 prop 传递,<Tabs><Tab/><TabPanel/></Tabs>,<Tabs><Tab/><TabPanel/></Tabs>,<Tabs tabs={[]} panels={[...]}/>,<Tabs tabs={[]} panels={[...]}/>,低 | Low,
